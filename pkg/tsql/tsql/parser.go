// Code generated by antlr2participle. DO NOT EDIT.
package tsql

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var (
	Rules = lexer.Rules{
		"Root": {
			{"comment", `/\*.*\*/`, nil},
			{"line_comment", `--[^\n]*`, nil},
			{"whitespace", `[ \t\r\n]+`, nil},
			{"ADD", `ADD`, nil},
			{"ALL", `ALL`, nil},
			{"ALTER", `ALTER`, nil},
			{"AND", `AND`, nil},
			{"ANY", `ANY`, nil},
			{"AS", `AS`, nil},
			{"ASC", `ASC`, nil},
			{"AUTHORIZATION", `AUTHORIZATION`, nil},
			{"BACKUP", `BACKUP`, nil},
			{"BEGIN", `BEGIN`, nil},
			{"BETWEEN", `BETWEEN`, nil},
			{"BREAK", `BREAK`, nil},
			{"BROWSE", `BROWSE`, nil},
			{"BULK", `BULK`, nil},
			{"BY", `BY`, nil},
			{"CASCADE", `CASCADE`, nil},
			{"CASE", `CASE`, nil},
			{"CHECK", `CHECK`, nil},
			{"CHECKPOINT", `CHECKPOINT`, nil},
			{"CLOSE", `CLOSE`, nil},
			{"CLUSTERED", `CLUSTERED`, nil},
			{"COALESCE", `COALESCE`, nil},
			{"COLLATE", `COLLATE`, nil},
			{"COLUMN", `COLUMN`, nil},
			{"COMMIT", `COMMIT`, nil},
			{"COMPUTE", `COMPUTE`, nil},
			{"CONSTRAINT", `CONSTRAINT`, nil},
			{"CONTAINS", `CONTAINS`, nil},
			{"CONTAINSTABLE", `CONTAINSTABLE`, nil},
			{"CONTINUE", `CONTINUE`, nil},
			{"CONVERT", `CONVERT`, nil},
			{"CREATE", `CREATE`, nil},
			{"CROSS", `CROSS`, nil},
			{"CURRENT", `CURRENT`, nil},
			{"CURRENT_DATE", `CURRENT_DATE`, nil},
			{"CURRENT_TIME", `CURRENT_TIME`, nil},
			{"CURRENT_TIMESTAMP", `CURRENT_TIMESTAMP`, nil},
			{"CURRENT_USER", `CURRENT_USER`, nil},
			{"CURSOR", `CURSOR`, nil},
			{"DATABASE", `DATABASE`, nil},
			{"DBCC", `DBCC`, nil},
			{"DEALLOCATE", `DEALLOCATE`, nil},
			{"DECLARE", `DECLARE`, nil},
			{"DEFAULT", `DEFAULT`, nil},
			{"DELETE", `DELETE`, nil},
			{"DENY", `DENY`, nil},
			{"DESC", `DESC`, nil},
			{"DISK", `DISK`, nil},
			{"DISTINCT", `DISTINCT`, nil},
			{"DISTRIBUTED", `DISTRIBUTED`, nil},
			{"DOUBLE", `DOUBLE`, nil},
			{"DROP", `DROP`, nil},
			{"DUMMY", `DUMMY`, nil},
			{"DUMP", `DUMP`, nil},
			{"ELSE", `ELSE`, nil},
			{"END", `END`, nil},
			{"ERRLVL", `ERRLVL`, nil},
			{"ESCAPE", `ESCAPE`, nil},
			{"EXCEPT", `EXCEPT`, nil},
			{"EXECUTE", `(EXECUTE|EXEC)`, nil},
			{"EXISTS", `EXISTS`, nil},
			{"EXIT", `EXIT`, nil},
			{"FETCH", `FETCH`, nil},
			{"FILE", `FILE`, nil},
			{"FILLFACTOR", `FILLFACTOR`, nil},
			{"FOR", `FOR`, nil},
			{"FOREIGN", `FOREIGN`, nil},
			{"FREETEXT", `FREETEXT`, nil},
			{"FREETEXTTABLE", `FREETEXTTABLE`, nil},
			{"FROM", `FROM`, nil},
			{"FULL", `FULL`, nil},
			{"FUNCTION", `FUNCTION`, nil},
			{"GOTO", `GOTO`, nil},
			{"GRANT", `GRANT`, nil},
			{"GROUP", `GROUP`, nil},
			{"HAVING", `HAVING`, nil},
			{"HOLDLOCK", `HOLDLOCK`, nil},
			{"IDENTITY", `IDENTITY`, nil},
			{"IDENTITY_INSERT", `IDENTITY_INSERT`, nil},
			{"IDENTITYCOL", `IDENTITYCOL`, nil},
			{"IF", `IF`, nil},
			{"IN", `IN`, nil},
			{"INDEX", `INDEX`, nil},
			{"INNER", `INNER`, nil},
			{"INSERT", `INSERT`, nil},
			{"INTERSECT", `INTERSECT`, nil},
			{"INTO", `INTO`, nil},
			{"IS", `IS`, nil},
			{"JOIN", `JOIN`, nil},
			{"KEY", `KEY`, nil},
			{"KILL", `KILL`, nil},
			{"LEFT", `LEFT`, nil},
			{"LIKE", `LIKE`, nil},
			{"LINENO", `LINENO`, nil},
			{"LOAD", `LOAD`, nil},
			{"NATIONAL", `NATIONAL`, nil},
			{"NOCHECK", `NOCHECK`, nil},
			{"NONCLUSTERED", `NONCLUSTERED`, nil},
			{"NOT", `NOT`, nil},
			{"NULL", `NULL`, nil},
			{"NULLIF", `NULLIF`, nil},
			{"OF", `OF`, nil},
			{"OFF", `OFF`, nil},
			{"OFFSETS", `OFFSETS`, nil},
			{"ON", `ON`, nil},
			{"OPEN", `OPEN`, nil},
			{"OPENDATASOURCE", `OPENDATASOURCE`, nil},
			{"OPENQUERY", `OPENQUERY`, nil},
			{"OPENROWSET", `OPENROWSET`, nil},
			{"OPENXML", `OPENXML`, nil},
			{"OPTION", `OPTION`, nil},
			{"OR", `OR`, nil},
			{"ORDER", `ORDER`, nil},
			{"OUTER", `OUTER`, nil},
			{"OVER", `OVER`, nil},
			{"PERCENT", `PERCENT`, nil},
			{"PLAN", `PLAN`, nil},
			{"PRECISION", `PRECISION`, nil},
			{"PRIMARY", `PRIMARY`, nil},
			{"PRINT", `PRINT`, nil},
			{"PROCEDURE", `PROCEDURE?`, nil},
			{"PUBLIC", `PUBLIC`, nil},
			{"RAISERROR", `RAISERROR`, nil},
			{"READ", `READ`, nil},
			{"READTEXT", `READTEXT`, nil},
			{"RECONFIGURE", `RECONFIGURE`, nil},
			{"REFERENCES", `REFERENCES`, nil},
			{"REPLICATION", `REPLICATION`, nil},
			{"RESTORE", `RESTORE`, nil},
			{"RESTRICT", `RESTRICT`, nil},
			{"RETURN", `RETURN`, nil},
			{"REVOKE", `REVOKE`, nil},
			{"RIGHT", `RIGHT`, nil},
			{"ROLLBACK", `ROLLBACK`, nil},
			{"ROWCOUNT", `ROWCOUNT`, nil},
			{"ROWGUIDCOL", `ROWGUIDCOL`, nil},
			{"RULE", `RULE`, nil},
			{"SAVE", `SAVE`, nil},
			{"SCHEMA", `SCHEMA`, nil},
			{"SELECT", `SELECT`, nil},
			{"SESSION_USER", `SESSION_USER`, nil},
			{"SET", `SET`, nil},
			{"SETUSER", `SETUSER`, nil},
			{"SHUTDOWN", `SHUTDOWN`, nil},
			{"SOME", `SOME`, nil},
			{"STATISTICS", `STATISTICS`, nil},
			{"SYSTEM_USER", `SYSTEM_USER`, nil},
			{"TABLE", `TABLE`, nil},
			{"TEXTSIZE", `TEXTSIZE`, nil},
			{"THEN", `THEN`, nil},
			{"TO", `TO`, nil},
			{"TOP", `TOP`, nil},
			{"TRANSACTION", `TRANSACTION?`, nil},
			{"TRIGGER", `TRIGGER`, nil},
			{"TRUNCATE", `TRUNCATE`, nil},
			{"TSEQUAL", `TSEQUAL`, nil},
			{"UNION", `UNION`, nil},
			{"UNIQUE", `UNIQUE`, nil},
			{"UPDATE", `UPDATE`, nil},
			{"UPDATETEXT", `UPDATETEXT`, nil},
			{"USE", `USE`, nil},
			{"USER", `USER`, nil},
			{"VALUES", `VALUES`, nil},
			{"VARYING", `VARYING`, nil},
			{"VIEW", `VIEW`, nil},
			{"WAITFOR", `WAITFOR`, nil},
			{"WHEN", `WHEN`, nil},
			{"WHERE", `WHERE`, nil},
			{"WHILE", `WHILE`, nil},
			{"WITH", `WITH`, nil},
			{"WRITETEXT", `WRITETEXT`, nil},
			{"STRING_LITERAL", `N?'(\\'|[^'])*'`, nil},
			{"INTEGER_LITERAL", `[0-9]+`, nil},
			{"REAL_LITERAL", `[0-9]*\.[0-9]+`, nil},
			{"HEX_LITERAL", `0x[0-9a-zA-Z]+`, nil},
			{"ID", `[a-zA-Z]([a-zA-Z0-9_])*`, nil},
			{"QUOTED_ID", `(\[[^\[\]#]([^\[\]])*\]|"[^"#]([^"#])*")`, nil},
			{"LOCAL_ID", `@[a-zA-Z]([a-zA-Z0-9_])*`, nil},
			{"SYSTEM_VAR_ID", `@@[a-zA-Z]([a-zA-Z0-9_])*`, nil},
			{"SYSTEM_FUNC_ID", `::[a-zA-Z]([a-zA-Z0-9_])*`, nil},
			{"TEMP_TABLE_ID", `(#[a-zA-Z]([a-zA-Z0-9_])*|\[#([^\[\]])+\]|"#([^"#])+")`, nil},
			{"terminator", `;`, nil},
			{"XXX__LITERAL_BangLt", `!<`, nil},
			{"XXX__LITERAL_BangEq", `!=`, nil},
			{"XXX__LITERAL_BangGt", `!>`, nil},
			{"XXX__LITERAL_Dollar", `\$`, nil},
			{"XXX__LITERAL_DollarAction", `\$ACTION`, nil},
			{"XXX__LITERAL_Percent", `%`, nil},
			{"XXX__LITERAL_PercentEq", `%=`, nil},
			{"XXX__LITERAL_Amp", `&`, nil},
			{"XXX__LITERAL_AmpEq", `&=`, nil},
			{"XXX__LITERAL_Lparen", `\(`, nil},
			{"XXX__LITERAL_LparenNoexpandRparen", `\(NOEXPAND\)`, nil},
			{"XXX__LITERAL_LparenNolockRparen", `\(NOLOCK\)`, nil},
			{"XXX__LITERAL_LparenNowaitRparen", `\(NOWAIT\)`, nil},
			{"XXX__LITERAL_LparenPaglockRparen", `\(PAGLOCK\)`, nil},
			{"XXX__LITERAL_LparenReadcommittedRparen", `\(READCOMMITTED\)`, nil},
			{"XXX__LITERAL_LparenReadpastRparen", `\(READPAST\)`, nil},
			{"XXX__LITERAL_LparenReaduncommittedRparen", `\(READUNCOMMITTED\)`, nil},
			{"XXX__LITERAL_LparenRepeatablereadRparen", `\(REPEATABLEREAD\)`, nil},
			{"XXX__LITERAL_LparenRowlockRparen", `\(ROWLOCK\)`, nil},
			{"XXX__LITERAL_LparenSerializableRparen", `\(SERIALIZABLE\)`, nil},
			{"XXX__LITERAL_LparenTablockRparen", `\(TABLOCK\)`, nil},
			{"XXX__LITERAL_LparenTablockxRparen", `\(TABLOCKX\)`, nil},
			{"XXX__LITERAL_LparenUpdlockRparen", `\(UPDLOCK\)`, nil},
			{"XXX__LITERAL_LparenXlockRparen", `\(XLOCK\)`, nil},
			{"XXX__LITERAL_Rparen", `\)`, nil},
			{"XXX__LITERAL_Star", `\*`, nil},
			{"XXX__LITERAL_StarEq", `\*=`, nil},
			{"XXX__LITERAL_Plus", `\+`, nil},
			{"XXX__LITERAL_PlusEq", `\+=`, nil},
			{"XXX__LITERAL_Comma", `,`, nil},
			{"XXX__LITERAL_Minus", `-`, nil},
			{"XXX__LITERAL_MinusEq", `-=`, nil},
			{"XXX__LITERAL_Stop", `\.`, nil},
			{"XXX__LITERAL_Fslash", `/`, nil},
			{"XXX__LITERAL_FslashEq", `/=`, nil},
			{"XXX__LITERAL_Colon", `:`, nil},
			{"XXX__LITERAL_Lt", `<`, nil},
			{"XXX__LITERAL_LtEq", `<=`, nil},
			{"XXX__LITERAL_LtGt", `<>`, nil},
			{"XXX__LITERAL_Eq", `=`, nil},
			{"XXX__LITERAL_Gt", `>`, nil},
			{"XXX__LITERAL_GtEq", `>=`, nil},
			{"XXX__LITERAL_Absolute", `ABSOLUTE`, nil},
			{"XXX__LITERAL_Action", `ACTION`, nil},
			{"XXX__LITERAL_After", `AFTER`, nil},
			{"XXX__LITERAL_Apply", `APPLY`, nil},
			{"XXX__LITERAL_Auto", `AUTO`, nil},
			{"XXX__LITERAL_Called", `CALLED`, nil},
			{"XXX__LITERAL_Caller", `CALLER`, nil},
			{"XXX__LITERAL_Cast", `CAST`, nil},
			{"XXX__LITERAL_Catch", `CATCH`, nil},
			{"XXX__LITERAL_ChangeTracking", `CHANGE_TRACKING`, nil},
			{"XXX__LITERAL_Collection", `COLLECTION`, nil},
			{"XXX__LITERAL_Committed", `COMMITTED`, nil},
			{"XXX__LITERAL_Concat", `CONCAT`, nil},
			{"XXX__LITERAL_Count", `COUNT`, nil},
			{"XXX__LITERAL_DataCompression", `DATA_COMPRESSION`, nil},
			{"XXX__LITERAL_Disable", `DISABLE`, nil},
			{"XXX__LITERAL_Enable", `ENABLE`, nil},
			{"XXX__LITERAL_Explicit", `EXPLICIT`, nil},
			{"XXX__LITERAL_ExternalSpaceName", `EXTERNAL NAME`, nil},
			{"XXX__LITERAL_Fast", `FAST`, nil},
			{"XXX__LITERAL_First", `FIRST`, nil},
			{"XXX__LITERAL_ForSpaceReadSpaceOnly", `FOR READ ONLY`, nil},
			{"XXX__LITERAL_ForSpaceUpdate", `FOR UPDATE`, nil},
			{"XXX__LITERAL_ForSpaceUpdateSpaceOf", `FOR UPDATE OF`, nil},
			{"XXX__LITERAL_Fulltext", `FULLTEXT`, nil},
			{"XXX__LITERAL_Global", `GLOBAL`, nil},
			{"XXX__LITERAL_Go", `GO`, nil},
			{"XXX__LITERAL_Hash", `HASH`, nil},
			{"XXX__LITERAL_Include", `INCLUDE`, nil},
			{"XXX__LITERAL_Input", `INPUT`, nil},
			{"XXX__LITERAL_Insensitive", `INSENSITIVE`, nil},
			{"XXX__LITERAL_Instead", `INSTEAD`, nil},
			{"XXX__LITERAL_Language", `LANGUAGE`, nil},
			{"XXX__LITERAL_Last", `LAST`, nil},
			{"XXX__LITERAL_Log", `LOG`, nil},
			{"XXX__LITERAL_Loop", `LOOP`, nil},
			{"XXX__LITERAL_Manual", `MANUAL`, nil},
			{"XXX__LITERAL_Mark", `MARK`, nil},
			{"XXX__LITERAL_Matched", `MATCHED`, nil},
			{"XXX__LITERAL_Maxrecursion", `MAXRECURSION`, nil},
			{"XXX__LITERAL_Merge", `MERGE`, nil},
			{"XXX__LITERAL_Next", `NEXT`, nil},
			{"XXX__LITERAL_No", `NO`, nil},
			{"XXX__LITERAL_Nolock", `NOLOCK`, nil},
			{"XXX__LITERAL_None", `NONE`, nil},
			{"XXX__LITERAL_Nowait", `NOWAIT`, nil},
			{"XXX__LITERAL_Only", `ONLY`, nil},
			{"XXX__LITERAL_Optimize", `OPTIMIZE`, nil},
			{"XXX__LITERAL_Output", `OUTPUT`, nil},
			{"XXX__LITERAL_Page", `PAGE`, nil},
			{"XXX__LITERAL_Paglock", `PAGLOCK`, nil},
			{"XXX__LITERAL_Partition", `PARTITION`, nil},
			{"XXX__LITERAL_Path", `PATH`, nil},
			{"XXX__LITERAL_Persisted", `PERSISTED`, nil},
			{"XXX__LITERAL_Population", `POPULATION`, nil},
			{"XXX__LITERAL_Prior", `PRIOR`, nil},
			{"XXX__LITERAL_Privileges", `PRIVILEGES`, nil},
			{"XXX__LITERAL_Property", `PROPERTY`, nil},
			{"XXX__LITERAL_Raw", `RAW`, nil},
			{"XXX__LITERAL_Readcommitted", `READCOMMITTED`, nil},
			{"XXX__LITERAL_Readcommittedlock", `READCOMMITTEDLOCK`, nil},
			{"XXX__LITERAL_Readonly", `READONLY`, nil},
			{"XXX__LITERAL_Readpast", `READPAST`, nil},
			{"XXX__LITERAL_Readuncommitted", `READUNCOMMITTED`, nil},
			{"XXX__LITERAL_Recompile", `RECOMPILE`, nil},
			{"XXX__LITERAL_Relative", `RELATIVE`, nil},
			{"XXX__LITERAL_Repeatable", `REPEATABLE`, nil},
			{"XXX__LITERAL_Repeatableread", `REPEATABLEREAD`, nil},
			{"XXX__LITERAL_Returns", `RETURNS`, nil},
			{"XXX__LITERAL_Row", `ROW`, nil},
			{"XXX__LITERAL_Rowlock", `ROWLOCK`, nil},
			{"XXX__LITERAL_Schemabinding", `SCHEMABINDING`, nil},
			{"XXX__LITERAL_Scroll", `SCROLL`, nil},
			{"XXX__LITERAL_Serializable", `SERIALIZABLE`, nil},
			{"XXX__LITERAL_Server", `SERVER`, nil},
			{"XXX__LITERAL_Seterror", `SETERROR`, nil},
			{"XXX__LITERAL_Source", `SOURCE`, nil},
			{"XXX__LITERAL_Tablock", `TABLOCK`, nil},
			{"XXX__LITERAL_Tablockx", `TABLOCKX`, nil},
			{"XXX__LITERAL_Target", `TARGET`, nil},
			{"XXX__LITERAL_Ties", `TIES`, nil},
			{"XXX__LITERAL_Try", `TRY`, nil},
			{"XXX__LITERAL_TryCast", `TRY_CAST`, nil},
			{"XXX__LITERAL_TryConvert", `TRY_CONVERT`, nil},
			{"XXX__LITERAL_Type", `TYPE`, nil},
			{"XXX__LITERAL_Uncommitted", `UNCOMMITTED`, nil},
			{"XXX__LITERAL_Updlock", `UPDLOCK`, nil},
			{"XXX__LITERAL_Using", `USING`, nil},
			{"XXX__LITERAL_Value", `VALUE`, nil},
			{"XXX__LITERAL_ViewMetadata", `VIEW_METADATA`, nil},
			{"XXX__LITERAL_WithCheckOption", `WITH_CHECK_OPTION`, nil},
			{"XXX__LITERAL_Work", `WORK`, nil},
			{"XXX__LITERAL_Xlock", `XLOCK`, nil},
			{"XXX__LITERAL_Xml", `XML`, nil},
			{"XXX__LITERAL_Xmlnamespaces", `XMLNAMESPACES`, nil},
			{"XXX__LITERAL_Caret", `\^`, nil},
			{"XXX__LITERAL_CaretEq", `\^=`, nil},
			{"XXX__LITERAL_Pipe", `\|`, nil},
			{"XXX__LITERAL_PipeEq", `\|=`, nil},
			{"XXX__LITERAL_Tilde", `~`, nil},
		},
	}
	Lexer  = lexer.MustStateful(Rules, lexer.MatchLongest())
	Parser = participle.MustBuild(
		&Script{},
		participle.Lexer(Lexer),
		participle.UseLookahead(2),
	)
)

type ObjectName struct {
	QuotedId *string `@QUOTED_ID`
	Id       *string `| @ID`
}
type ObjectNameQualified struct {
	SchemaName *SchemaName `( @@ '.' )?`
	ObjectName *ObjectName `@@`
}
type AliasName struct {
	ObjectName    *ObjectName `@@`
	StringLiteral *string     `| @STRING_LITERAL`
}
type AssemblyName struct {
	ObjectName *ObjectName `@@`
}
type ClassName struct {
	ObjectName *ObjectName `@@`
}
type CollationName struct {
	Id *string `@ID`
}
type ColumnName struct {
	ObjectName *ObjectName `@@ | '$ACTION'`
}
type ColumnNameFullyQualified struct {
	SchemaName  *SchemaName `@@`
	TableName   *TableName  `'.' @@`
	ColumnName  *ColumnName `'.' @@`
	TableName2  *TableName  `| @@`
	ColumnName2 *ColumnName `'.' @@`
	ColumnName3 *ColumnName `| @@`
}
type ColumnNameQualified struct {
	TableName  *TableName  `( @@ '.' )?`
	ColumnName *ColumnName `@@`
}
type ColumnNameList struct {
	ColumnName []*ColumnName `@@ ( ',' @@ )*`
}
type ColumnNameQualifiedList struct {
	ColumnNameQualified []*ColumnNameQualified `@@ ( ',' @@ )*`
}
type ColumnWild struct {
	Star bool `@( '*' )`
}
type ColumnWildQualified struct {
	VariableName *VariableName `( ( @@`
	TableName    *TableName    `| @@ ) '.' )?`
	ColumnWild   *ColumnWild   `@@`
}
type ColumnWildNameQualified struct {
	ColumnNameQualified *ColumnNameQualified `@@`
	ColumnWildQualified *ColumnWildQualified `| @@`
}
type ConstraintName struct {
	ObjectName *ObjectName `@@`
}
type CursorName struct {
	ObjectName *ObjectName `@@`
}
type FunctionName struct {
	ObjectName   *ObjectName `@@`
	SystemFuncId *string     `| @SYSTEM_FUNC_ID`
}
type FunctionNameQualified struct {
	SchemaName   *SchemaName   `( @@ '.' )?`
	FunctionName *FunctionName `@@`
}
type IndexName struct {
	ObjectName *ObjectName `@@`
}
type LabelName struct {
	ObjectName *ObjectName `@@`
}
type Label struct {
	LabelName *LabelName `@@ ':'`
}
type MethodName struct {
	ObjectName *ObjectName `@@`
}
type ParameterName struct {
	LocalId *string `@LOCAL_ID`
}
type ProcedureName struct {
	ObjectName *ObjectName `@@`
}
type ProcedureNameQualified struct {
	SchemaName    *SchemaName    `( @@ '.' )?`
	ProcedureName *ProcedureName `@@`
}
type TableName struct {
	ObjectName  *ObjectName `@@`
	TempTableId *string     `| @TEMP_TABLE_ID`
}
type TableNameQualified struct {
	SchemaName *SchemaName `( @@ '.' )?`
	TableName  *TableName  `@@`
}
type TransactionName struct {
	ObjectName *ObjectName `@@`
}
type TriggerName struct {
	ObjectName *ObjectName `@@`
}
type TriggerNameQualified struct {
	SchemaName  *SchemaName  `( @@ '.' )?`
	TriggerName *TriggerName `@@`
}
type SimpleTypeName struct {
	ObjectName *ObjectName `@@`
}
type SimpleTypeNameQualified struct {
	SchemaName     *SchemaName     `( @@ '.' )?`
	SimpleTypeName *SimpleTypeName `@@`
}
type TypeName struct {
	ObjectName      *ObjectName     `@@`
	Id              *string         `( '(' ( @ID`
	IntegerLiteral  *IntegerLiteral `| ( @@`
	IntegerLiteral2 *IntegerLiteral `( ',' @@ )? ) ) ')' )?`
}
type TypeNameQualified struct {
	SchemaName *SchemaName `@@`
	TypeName   *TypeName   `'.' @@`
	TypeName2  *TypeName   `| @@`
}
type SchemaName struct {
	ObjectName *ObjectName `@@`
}
type SystemVariableName struct {
	SystemVarId *string `@SYSTEM_VAR_ID`
}
type VariableName struct {
	LocalId *string `@LOCAL_ID`
}
type ViewName struct {
	ObjectName *ObjectName `@@`
}
type ViewNameQualified struct {
	SchemaName *SchemaName `@@`
	ViewName   *ViewName   `'.' @@`
	ViewName2  *ViewName   `| @@`
}
type XmlNamespaceName struct {
	ObjectName *ObjectName `@@`
}
type XmlSchemaCollectionName struct {
	ObjectName *ObjectName `@@`
}
type XmlSchemaCollectionNameQualified struct {
	SchemaName               *SchemaName              `@@`
	XmlSchemaCollectionName  *XmlSchemaCollectionName `'.' @@`
	XmlSchemaCollectionName2 *XmlSchemaCollectionName `| @@`
}
type ExternalName struct {
	AssemblyName *AssemblyName `'EXTERNAL NAME' @@`
	ClassName    *ClassName    `'.' @@`
	MethodName   *MethodName   `'.' @@`
}
type StringLiteral struct {
	StringLiteral *string `@STRING_LITERAL`
}
type IntegerLiteral struct {
	IntegerLiteral *string `@INTEGER_LITERAL`
	HexLiteral     *string `| @HEX_LITERAL`
}
type NumberLiteral struct {
	RealLiteral    *string         `@REAL_LITERAL`
	IntegerLiteral *IntegerLiteral `| @@`
}
type PriceLiteral struct {
	NumberLiteral *NumberLiteral `'$' @@`
}
type Literal struct {
	PriceLiteral   *PriceLiteral  `@@`
	NumberLiteral  *NumberLiteral `| @@`
	StringLiteral  *StringLiteral `| @@`
	StringLiteral2 *string        `| @STRING_LITERAL`
	CollationName  *CollationName `'COLLATE' @@`
	Null           bool           `| @'NULL'`
}
type Toggle struct {
	OnOff *string `@( 'ON' | 'OFF' )`
}
type Script struct {
	Batch []*Batch `@@ ( 'GO' @@? )*`
}
type Batch struct {
	FirstStatement *FirstStatement `@@`
	StatementList  *StatementList  `| @@`
}
type StatementList struct {
	Statement []*Statement `@@+`
}
type Statement struct {
	StatementBlock   *StatementBlock   `@@`
	GenericStatement *GenericStatement `| @@`
}
type StatementBlock struct {
	GenericStatementList *GenericStatementList `'BEGIN' @@ 'END'`
}
type GenericStatementList struct {
	GenericStatement     *GenericStatement     `@@`
	GenericStatementList *GenericStatementList `@@?`
}
type FirstStatement struct {
	CreateOrAlterFunctionStatement  *CreateOrAlterFunctionStatement  `@@`
	CreateOrAlterProcedureStatement *CreateOrAlterProcedureStatement `| @@`
	CreateTriggerStatement          *CreateTriggerStatement          `| @@`
	CreateOrAlterViewStatement      *CreateOrAlterViewStatement      `| @@`
	GrantStatement                  *GrantStatement                  `| @@`
}
type GenericStatement struct {
	DDlstatement *DDlstatement `@@`
	DMlstatement *DMlstatement `| @@`
	PrgStatement *PrgStatement `| @@`
	Label        *Label        `| @@`
}
type DDlstatement struct {
	CreateFulltextStatement            *CreateFulltextStatement            `@@`
	DropFulltextStatement              *DropFulltextStatement              `| @@`
	DropFunctionStatement              *DropFunctionStatement              `| @@`
	CreateIndexStatement               *CreateIndexStatement               `| @@`
	DropIndexStatement                 *DropIndexStatement                 `| @@`
	DropProcedureStatement             *DropProcedureStatement             `| @@`
	CreateTableStatement               *CreateTableStatement               `| @@`
	AlterTableStatement                *AlterTableStatement                `| @@`
	DropTableStatement                 *DropTableStatement                 `| @@`
	EnableTriggerStatement             *EnableTriggerStatement             `| @@`
	DisableTriggerStatement            *DisableTriggerStatement            `| @@`
	DropTriggerStatement               *DropTriggerStatement               `| @@`
	CreateTypeStatement                *CreateTypeStatement                `| @@`
	DropTypeStatement                  *DropTypeStatement                  `| @@`
	DropViewStatement                  *DropViewStatement                  `| @@`
	CreateXmlSchemaCollectionStatement *CreateXmlSchemaCollectionStatement `| @@`
	DropXmlSchemaCollectionStatement   *DropXmlSchemaCollectionStatement   `| @@`
}
type DMlstatement struct {
	SelectStatement *SelectStatement `@@`
	InsertStatement *InsertStatement `| @@`
	UpdateStatement *UpdateStatement `| @@`
	DeleteStatement *DeleteStatement `| @@`
	MergeStatement  *MergeStatement  `| @@`
}
type PrgStatement struct {
	UseStatement                 *UseStatement                 `@@`
	BeginTransactionStatement    *BeginTransactionStatement    `| @@`
	BreakStatement               *BreakStatement               `| @@`
	CloseStatement               *CloseStatement               `| @@`
	CommitTransactionStatement   *CommitTransactionStatement   `| @@`
	ContinueStatement            *ContinueStatement            `| @@`
	DeallocateStatement          *DeallocateStatement          `| @@`
	DeclareStatement             *DeclareStatement             `| @@`
	ExecuteStatement             *ExecuteStatement             `| @@`
	FetchStatement               *FetchStatement               `| @@`
	GotoStatement                *GotoStatement                `| @@`
	IfStatement                  *IfStatement                  `| @@`
	OpenStatement                *OpenStatement                `| @@`
	PrintStatement               *PrintStatement               `| @@`
	ReturnStatement              *ReturnStatement              `| @@`
	RollbackTransactionStatement *RollbackTransactionStatement `| @@`
	SaveTransactionStatement     *SaveTransactionStatement     `| @@`
	SetStatement                 *SetStatement                 `| @@`
	TryCatchStatement            *TryCatchStatement            `| @@`
	WaitforStatement             *WaitforStatement             `| @@`
	WhileStatement               *WhileStatement               `| @@`
	RaiserrorStatement           *RaiserrorStatement           `| @@`
	AnyStatement                 *AnyStatement                 `| @@`
}
type GrantStatement struct {
	GrantPermissionList  *GrantPermissionList  `'GRANT' @@`
	ObjectNameQualified  *ObjectNameQualified  `'ON' @@`
	ToPricipalWithOption *ToPricipalWithOption `@@`
}
type GrantPermissionList struct {
	GrantPermission     *GrantPermission     `@@`
	GrantPermission2    *GrantPermission     `| @@`
	GrantPermissionList *GrantPermissionList `',' @@`
}
type GrantPermission struct {
	Execute       *string `@EXECUTE`
	References    bool    `| @'REFERENCES'`
	Delete        bool    `| @'DELETE'`
	Insert        bool    `| @'INSERT'`
	Select        bool    `| @'SELECT'`
	Update        bool    `| @'UPDATE'`
	All           bool    `| @'ALL'`
	AllPrivileges bool    `| @( 'ALL' 'PRIVILEGES' )`
}
type DatabasePrincipalList struct {
	DatabasePrincipal []*DatabasePrincipal `@@ ( ',' @@ )*`
}
type DatabasePrincipal struct {
	Public bool `@( 'PUBLIC' )`
}
type AsDatabasePrincipal struct {
	DatabasePrincipal *DatabasePrincipal `'AS' @@`
}
type WithGrantOption struct {
	WithGrantOption bool `@( 'WITH' 'GRANT' 'OPTION' )`
}
type ToPricipalWithOption struct {
	DatabasePrincipalList *DatabasePrincipalList `'TO' @@`
	WithGrantOption       *WithGrantOption       `@@?`
	AsDatabasePrincipal   *AsDatabasePrincipal   `@@?`
}
type BreakStatement struct {
	Break bool `@( 'BREAK' )`
}
type ContinueStatement struct {
	Continue bool `@( 'CONTINUE' )`
}
type GotoStatement struct {
	LabelName *LabelName `'GOTO' @@`
}
type IfStatement struct {
	Predicate  *Predicate `'IF' @@`
	Statement  *Statement `@@`
	Statement2 *Statement `( 'ELSE' @@ )?`
}
type ReturnStatement struct {
	Expression *Expression `'RETURN' @@?`
}
type TryCatchStatement struct {
	StatementList  *StatementList `'BEGIN' 'TRY' @@`
	StatementList2 *StatementList `'END' 'TRY' 'BEGIN' 'CATCH' @@ 'END' 'CATCH'`
}
type WhileStatement struct {
	Predicate *Predicate `'WHILE' @@`
	Statement *Statement `@@`
}
type WaitforStatement struct {
	Id            *string        `'WAITFOR' @ID`
	StringLiteral *StringLiteral `( @@`
	VariableName  *VariableName  `| @@ )`
}
type PrintStatement struct {
	Expression *Expression `'PRINT' @@`
}
type AnyStatement struct {
	Id             *string         `@ID`
	ExpressionList *ExpressionList `@@`
}
type UseStatement struct {
	Id *string `'USE' @ID`
}
type RaiserrorStatement struct {
	ExpressionList      *ExpressionList      `'RAISERROR' '(' @@`
	RaiserrorOptionList *RaiserrorOptionList `')' ( 'WITH' @@ )?`
}
type RaiserrorOption struct {
	LogNowaitSeterror *string `@( 'LOG' | 'NOWAIT' | 'SETERROR' )`
}
type RaiserrorOptionList struct {
	RaiserrorOption []*RaiserrorOption `@@ ( ',' @@ )*`
}
type DeclareStatement struct {
	VariableName          *VariableName         `'DECLARE' ( @@`
	TableDefinitionGroup  *TableDefinitionGroup `'AS' 'TABLE' @@`
	VariableName2         *VariableName         `| @@`
	TableDefinitionGroup2 *TableDefinitionGroup `'TABLE' @@`
	DeclareItemList       *DeclareItemList      `| @@`
	CursorName            *CursorName           `| @@`
	CursorDefinition      *CursorDefinition     `@@ )`
}
type CursorDefinition struct {
	CursorType       *CursorType       `@@?`
	CursorOptionList *CursorOptionList `'CURSOR' @@?`
	SelectStatement  *SelectStatement  `'FOR' @@`
	CursorUpdate     *CursorUpdate     `@@?`
}
type CursorType struct {
	InsensitiveScroll *string `@( 'INSENSITIVE' | 'SCROLL' )`
}
type DeclareItem struct {
	VariableName      *VariableName      `@@ 'CURSOR'`
	VariableName2     *VariableName      `| @@`
	TypeNameQualified *TypeNameQualified `'AS'? @@`
	Expression        *Expression        `( '=' @@ )?`
}
type DeclareItemList struct {
	DeclareItem []*DeclareItem `@@ ( ',' @@ )*`
}
type CursorOptionList struct {
	Id               *string           `@ID`
	CursorOptionList *CursorOptionList `@@?`
}
type CloseStatement struct {
	GlobalOrLocalCursor *GlobalOrLocalCursor `'CLOSE' @@`
}
type OpenStatement struct {
	GlobalOrLocalCursor *GlobalOrLocalCursor `'OPEN' @@`
}
type DeallocateStatement struct {
	GlobalOrLocalCursor *GlobalOrLocalCursor `'DEALLOCATE' @@`
}
type GlobalOrLocalCursor struct {
	VariableName *VariableName `@@`
	CursorName   *CursorName   `| @@`
	CursorName2  *CursorName   `| 'GLOBAL' @@`
}
type CursorUpdate struct {
	ColumnNameList        *ColumnNameList `'FOR UPDATE OF' @@`
	ForSpaceUpdate        bool            `| @'FOR UPDATE'`
	ForSpaceReadSpaceOnly bool            `| @'FOR READ ONLY'`
}
type FetchStatement struct {
	CursorPosition      *CursorPosition      `'FETCH' @@?`
	GlobalOrLocalCursor *GlobalOrLocalCursor `@@`
	VariableNameList    *VariableNameList    `( 'INTO' @@ )?`
}
type CursorPosition struct {
	NextFrom        bool            `@( 'NEXT' 'FROM' )`
	PriorFrom       bool            `| @( 'PRIOR' 'FROM' )`
	FirstFrom       bool            `| @( 'FIRST' 'FROM' )`
	LastFrom        bool            `| @( 'LAST' 'FROM' )`
	IntegerLiteral  *IntegerLiteral `| 'ABSOLUTE' @@ 'FROM'`
	VariableName    *VariableName   `| 'ABSOLUTE' @@ 'FROM'`
	IntegerLiteral2 *IntegerLiteral `| 'RELATIVE' @@ 'FROM'`
	VariableName2   *VariableName   `| 'RELATIVE' @@ 'FROM'`
	From            bool            `| @'FROM'`
}
type VariableNameList struct {
	VariableName []*VariableName `@@ ( ',' @@ )*`
}
type OptionalDefault struct {
	Literal *Literal `'=' @@`
}
type DestinationRowset struct {
	VariableName       *VariableName       `@@`
	TableNameQualified *TableNameQualified `| @@`
	TableHintGroup     *TableHintGroup     `@@?`
}
type Openxml struct {
	VariableName           *VariableName          `'OPENXML' '(' @@`
	StringLiteral          *StringLiteral         `',' @@`
	IntegerLiteral         *IntegerLiteral        `',' @@`
	OptionalOpenxmlSchema  *OptionalOpenxmlSchema `')' @@?`
	VariableName2          *VariableName          `| 'OPENXML' '(' @@`
	VariableName3          *VariableName          `',' @@`
	IntegerLiteral2        *IntegerLiteral        `',' @@`
	OptionalOpenxmlSchema2 *OptionalOpenxmlSchema `')' @@?`
	VariableName4          *VariableName          `| 'OPENXML' '(' @@`
	StringLiteral2         *StringLiteral         `',' @@`
	OptionalOpenxmlSchema3 *OptionalOpenxmlSchema `')' @@?`
	VariableName5          *VariableName          `| 'OPENXML' '(' @@`
	VariableName6          *VariableName          `',' @@`
	OptionalOpenxmlSchema4 *OptionalOpenxmlSchema `')' @@?`
}
type OptionalOpenxmlSchema struct {
	OpenxmlImplicitSchema *OpenxmlImplicitSchema `@@`
	OpenxmlExplicitSchema *OpenxmlExplicitSchema `| @@`
}
type OpenxmlImplicitSchema struct {
	TableNameQualified *TableNameQualified `'WITH' '(' @@ ')'`
}
type OpenxmlExplicitSchema struct {
	OpenxmlColumnList *OpenxmlColumnList `'WITH' '(' @@ ')'`
}
type OpenxmlColumnList struct {
	OpenxmlColumn []*OpenxmlColumn `@@ ( ',' @@ )*`
}
type OpenxmlColumn struct {
	ColumnName    *ColumnName    `@@`
	TypeName      *TypeName      `@@`
	StringLiteral *StringLiteral `@@`
	ColumnName2   *ColumnName    `| @@`
	TypeName2     *TypeName      `@@`
}
type SetStatement struct {
	SetVariableStatement *SetVariableStatement `@@`
	SetOptionStatement   *SetOptionStatement   `| @@`
}
type SetVariableStatement struct {
	VariableName      *VariableName      `'SET' @@`
	Expression        *Expression        `( '=' @@`
	NamedFunctionList *NamedFunctionList `| '.' @@`
	CursorDefinition  *CursorDefinition  `| '=' @@ )`
}
type SetOptionStatement struct {
	Id                 *string             `'SET' ( @ID`
	SetValueList       *SetValueList       `@@`
	Transaction        *string             `| @TRANSACTION`
	SetValueList2      *SetValueList       `@@`
	SetValueList3      *SetValueList       `| 'OFFSETS' @@`
	SetValue           *SetValue           `| 'ROWCOUNT' @@`
	SetValueList4      *SetValueList       `| 'STATISTICS' @@`
	TableNameQualified *TableNameQualified `| 'IDENTITY_INSERT' @@`
	Toggle             *Toggle             `@@ )`
}
type SetValueList struct {
	SetValue []*SetValue `@@+`
}
type SetValue struct {
	Id              *string         `@ID`
	ReadUncommitted bool            `| @( 'READ' 'UNCOMMITTED' )`
	ReadCommitted   bool            `| @( 'READ' 'COMMITTED' )`
	RepeatableRead  bool            `| @( 'REPEATABLE' 'READ' )`
	Toggle          *Toggle         `| @@`
	IntegerLiteral  *IntegerLiteral `| @@`
	StringValue     *StringValue    `| @@`
}
type StringValue struct {
	StringLiteral *StringLiteral `@@`
	VariableName  *VariableName  `| @@`
}
type BeginTransactionStatement struct {
	Transaction           *string                `'BEGIN' @TRANSACTION`
	TransactionIdentifier *TransactionIdentifier `( @@`
	StringLiteral         *StringLiteral         `( 'WITH' 'MARK' @@? )? )?`
}
type CommitTransactionStatement struct {
	Commit                bool                   `@'COMMIT'`
	CommitWork            bool                   `| @( 'COMMIT' 'WORK' )`
	Transaction           *string                `| 'COMMIT' @TRANSACTION`
	Transaction2          *string                `| 'COMMIT' @TRANSACTION`
	TransactionIdentifier *TransactionIdentifier `@@`
}
type RollbackTransactionStatement struct {
	Transaction           *string                `'ROLLBACK' ( 'WORK' | @TRANSACTION`
	TransactionIdentifier *TransactionIdentifier `@@? )?`
}
type SaveTransactionStatement struct {
	Transaction           *string                `'SAVE' @TRANSACTION`
	TransactionIdentifier *TransactionIdentifier `@@`
}
type TransactionIdentifier struct {
	TransactionName *TransactionName `@@`
	VariableName    *VariableName    `| @@`
}
type CreateFulltextStatement struct {
	TableNameQualified     *TableNameQualified     `'CREATE' 'FULLTEXT' 'INDEX' 'ON' 'TABLE' @@`
	FulltextColumnGroup    *FulltextColumnGroup    `@@?`
	IndexName              *IndexName              `'KEY' 'INDEX' @@`
	FulltextChangeTracking *FulltextChangeTracking `@@?`
}
type FulltextColumnGroup struct {
	FulltextColumnList *FulltextColumnList `'(' @@ ')'`
}
type FulltextColumnList struct {
	FulltextColumn []*FulltextColumn `@@ ( ',' @@ )*`
}
type FulltextColumn struct {
	ColumnName         *ColumnName         `@@`
	FulltextColumnType *FulltextColumnType `@@?`
	OptionalLanguage   *OptionalLanguage   `@@?`
}
type FulltextColumnType struct {
	TypeNameQualified *TypeNameQualified `'TYPE' 'COLUMN' @@`
}
type OptionalLanguage struct {
	IntegerLiteral *IntegerLiteral `'LANGUAGE' ( @@`
	StringLiteral  *StringLiteral  `| @@ )`
}
type FulltextChangeTracking struct {
	Auto     bool `'WITH' 'CHANGE_TRACKING' ( @'AUTO'`
	Manual   bool `| @'MANUAL'`
	Off      bool `| @'OFF'`
	OffNoPop bool `| @( 'OFF' ',' 'NO' 'POPULATION' ) )`
}
type DropFulltextStatement struct {
	TableNameQualified *TableNameQualified `'DROP' 'FULLTEXT' 'INDEX' 'ON' @@`
}
type CreateOrAlterFunctionStatement struct {
	Op                            *string                        `@( 'CREATE' | 'ALTER' )`
	FunctionNameQualified         *FunctionNameQualified         `'FUNCTION' @@`
	OptionalFunctionParameterList *OptionalFunctionParameterList `'(' @@?`
	TypeNameQualified             *TypeNameQualified             `')' 'RETURNS' ( @@`
	OptionalFunctionOption        *OptionalFunctionOption        `@@?`
	StatementBlock                *StatementBlock                `'AS'? @@`
	OptionalFunctionOption2       *OptionalFunctionOption        `| 'TABLE' @@?`
	FunctionInlineSelect          *FunctionInlineSelect          `'AS'? 'RETURN' @@`
	VariableName                  *VariableName                  `| @@`
	TableDefinitionGroup          *TableDefinitionGroup          `'TABLE' @@`
	OptionalFunctionOption3       *OptionalFunctionOption        `@@?`
	StatementBlock2               *StatementBlock                `'AS'? @@`
	TypeNameQualified2            *TypeNameQualified             `| @@`
	OptionalFunctionOption4       *OptionalFunctionOption        `@@?`
	ExternalName                  *ExternalName                  `'AS'? @@`
	TableDefinitionGroup2         *TableDefinitionGroup          `| 'TABLE' @@`
	OptionalFunctionOption5       *OptionalFunctionOption        `@@?`
	ExternalName2                 *ExternalName                  `'AS'? @@ )`
}
type OptionalFunctionParameterList struct {
	FunctionParameterList *FunctionParameterList `@@`
}
type FunctionParameterList struct {
	FunctionParameter []*FunctionParameter `@@ ( ',' @@ )*`
}
type FunctionParameter struct {
	ParameterName      *ParameterName     `@@`
	TypeNameQualified  *TypeNameQualified `'AS' @@`
	OptionalDefault    *OptionalDefault   `@@?`
	OptionalReadonly   *OptionalReadonly  `@@?`
	ParameterName2     *ParameterName     `| @@`
	TypeNameQualified2 *TypeNameQualified `@@`
	OptionalDefault2   *OptionalDefault   `@@?`
	OptionalReadonly2  *OptionalReadonly  `@@?`
}
type FunctionInlineSelect struct {
	FunctionInlineSelect *FunctionInlineSelect `'(' @@ ')'`
	SelectStatement      *SelectStatement      `| @@`
}
type OptionalFunctionOption struct {
	WithReturnsNullOnNullInput bool    `@( 'WITH' 'RETURNS' 'NULL' 'ON' 'NULL' 'INPUT' )`
	WithCalledOnNullInput      bool    `| @( 'WITH' 'CALLED' 'ON' 'NULL' 'INPUT' )`
	Execute                    *string `| 'WITH' @EXECUTE 'AS' 'CALLER'`
	WithSchemabinding          bool    `| @( 'WITH' 'SCHEMABINDING' )`
}
type DropFunctionStatement struct {
	FunctionNameQualified *FunctionNameQualified `'DROP' 'FUNCTION' @@`
}
type CreateOrAlterProcedureStatement struct {
	Procedure                *string                  `'CREATE' @PROCEDURE`
	ProcedureNameQualified   *ProcedureNameQualified  `@@`
	ProcedureParameterGroup  *ProcedureParameterGroup `@@?`
	ProcedureOptionGroup     *ProcedureOptionGroup    `@@?`
	ProcedureFor             *ProcedureFor            `@@?`
	AsObjectBody             *AsObjectBody            `@@`
	Procedure2               *string                  `| 'ALTER' @PROCEDURE`
	ProcedureNameQualified2  *ProcedureNameQualified  `@@`
	ProcedureParameterGroup2 *ProcedureParameterGroup `@@?`
	ProcedureOptionGroup2    *ProcedureOptionGroup    `@@?`
	ProcedureFor2            *ProcedureFor            `@@?`
	AsObjectBody2            *AsObjectBody            `@@`
}
type AsObjectBody struct {
	StatementList *StatementList `'AS' @@`
}
type ProcedureParameterGroup struct {
	ProcedureParameterList  *ProcedureParameterList `'(' @@ ')'`
	ProcedureParameterList2 *ProcedureParameterList `| @@`
	LparenRparen            bool                    `| @( '(' ')' )`
}
type ProcedureParameterList struct {
	ProcedureParameter []*ProcedureParameter `@@ ( ',' @@ )*`
}
type ProcedureParameter struct {
	ParameterName     *ParameterName     `@@`
	TypeNameQualified *TypeNameQualified `@@`
	OptionalVarying   *OptionalVarying   `@@?`
	OptionalDefault   *OptionalDefault   `@@?`
	OptionalOutput    *OptionalOutput    `@@?`
	OptionalReadonly  *OptionalReadonly  `@@?`
}
type OptionalVarying struct {
	Varying bool `@( 'VARYING' )`
}
type OptionalOutput struct {
	Output bool `@( 'OUTPUT' )`
}
type OptionalReadonly struct {
	Readonly bool `@( 'READONLY' )`
}
type ProcedureOptionGroup struct {
	WithRecompile bool `@( 'WITH' 'RECOMPILE' )`
}
type ProcedureFor struct {
	ForReplication bool `@( 'FOR' 'REPLICATION' )`
}
type DropProcedureStatement struct {
	Procedure              *string                 `'DROP' @PROCEDURE`
	ProcedureNameQualified *ProcedureNameQualified `@@`
}
type ExecuteStatement struct {
	Execute                 *string                 `@EXECUTE`
	VariableName            *VariableName           `( @@`
	ProcedureNameQualified  *ProcedureNameQualified `'=' @@`
	ExecuteParameterGroup   *ExecuteParameterGroup  `@@?`
	ProcedureOptionGroup    *ProcedureOptionGroup   `@@?`
	ProcedureNameQualified2 *ProcedureNameQualified `| @@`
	ExecuteParameterGroup2  *ExecuteParameterGroup  `@@?`
	ProcedureOptionGroup2   *ProcedureOptionGroup   `@@? )`
}
type ExecuteParameterGroup struct {
	ExecuteParameterList *ExecuteParameterList `@@`
}
type ExecuteParameterList struct {
	ExecuteParameter []*ExecuteParameter `@@ ( ',' @@ )*`
}
type ExecuteParameter struct {
	TableNameQualified *TableNameQualified `@@`
	ParameterName      *ParameterName      `| ( @@ '=' )?`
	VariableName       *VariableName       `( @@`
	SystemVariableName *SystemVariableName `| @@`
	Literal            *Literal            `| @@ )`
	OptionalOutput     *OptionalOutput     `@@?`
}
type CreateTableStatement struct {
	TableNameQualified   *TableNameQualified   `'CREATE' 'TABLE' @@`
	TableDefinitionGroup *TableDefinitionGroup `@@`
	TableOptionList      *TableOptionList      `( 'WITH' '(' @@ ')' )?`
}
type TableOptionList struct {
	TableOption []*TableOption `@@ ( ',' @@ )*`
}
type TableOption struct {
	DataCompressionEqNoneRowPage bool `@( 'DATA_COMPRESSION' '=' ( 'NONE' | 'ROW' | 'PAGE' ) )`
}
type AlterTableStatement struct {
	TableNameQualified  *TableNameQualified  `'ALTER' 'TABLE' @@`
	ColumnName          *ColumnName          `( 'ALTER' 'COLUMN' @@`
	ColumnDefinition    *ColumnDefinition    `@@`
	ColumnName2         *ColumnName          `| 'ALTER' 'COLUMN' @@ 'ADD' 'ROWGUIDCOL'`
	ColumnName3         *ColumnName          `| 'ALTER' 'COLUMN' @@ 'DROP' 'ROWGUIDCOL'`
	ColumnName4         *ColumnName          `| 'ALTER' 'COLUMN' @@ 'ADD' 'PERSISTED'`
	ColumnName5         *ColumnName          `| 'ALTER' 'COLUMN' @@ 'DROP' 'PERSISTED'`
	ColumnName6         *ColumnName          `| 'ALTER' 'COLUMN' @@ 'ADD' 'NOT' 'FOR' 'REPLICATION'`
	ColumnName7         *ColumnName          `| 'ALTER' 'COLUMN' @@ 'DROP' 'NOT' 'FOR' 'REPLICATION'`
	TableCheck          *TableCheck          `| @@?`
	TableDefinitionList *TableDefinitionList `'ADD' @@`
	TableCheck2         *TableCheck          `| @@?`
	ColumnConstraint    *ColumnConstraint    `'ADD' @@`
	ColumnName8         *ColumnName          `'FOR' @@`
	TableCheck3         *TableCheck          `| @@?`
	ConstraintName      *ConstraintName      `'NOCHECK' 'CONSTRAINT' @@`
	TableCheck4         *TableCheck          `| @@? 'NOCHECK' 'CONSTRAINT' 'ALL'`
	TableCheck5         *TableCheck          `| @@?`
	ConstraintName2     *ConstraintName      `'CHECK' 'CONSTRAINT' @@`
	TableCheck6         *TableCheck          `| @@? 'CHECK' 'CONSTRAINT' 'ALL'`
	ConstraintName3     *ConstraintName      `| 'DROP' @@`
	ConstraintName4     *ConstraintName      `| 'DROP' 'CONSTRAINT' @@`
	ColumnName9         *ColumnName          `| 'DROP' 'COLUMN' @@ )`
}
type TableCheck struct {
	WithCheckWithNocheck *string `@( 'WITH' 'CHECK' | 'WITH' 'NOCHECK' )`
}
type DropTableStatement struct {
	TableNameQualified *TableNameQualified `'DROP' 'TABLE' @@`
}
type CreateOrAlterViewStatement struct {
	ViewNameQualified        *ViewNameQualified       `'CREATE' 'VIEW' @@`
	ColumnNameGroup          *ColumnNameGroup         `@@?`
	ViewOptionalAttribute    *ViewOptionalAttribute   `@@?`
	SelectStatement          *SelectStatement         `'AS' @@`
	ViewOptionalCheckOption  *ViewOptionalCheckOption `@@?`
	ViewNameQualified2       *ViewNameQualified       `| 'ALTER' 'VIEW' @@`
	ColumnNameGroup2         *ColumnNameGroup         `@@?`
	ViewOptionalAttribute2   *ViewOptionalAttribute   `@@?`
	SelectStatement2         *SelectStatement         `'AS' @@`
	ViewOptionalCheckOption2 *ViewOptionalCheckOption `@@?`
}
type ColumnNameGroup struct {
	ColumnNameList *ColumnNameList `'(' @@ ')'`
}
type ViewOptionalAttribute struct {
	WithViewMetadataWithSchemabinding *string `@( 'WITH' 'VIEW_METADATA' | 'WITH' 'SCHEMABINDING' )`
}
type ViewOptionalCheckOption struct {
	WithCheckOption bool `@( 'WITH_CHECK_OPTION' )`
}
type DropViewStatement struct {
	ViewNameQualified *ViewNameQualified `'DROP' 'VIEW' @@`
}
type CreateIndexStatement struct {
	IndexName           *IndexName           `'CREATE' ( 'PRIMARY'? 'XML' 'INDEX' @@`
	TableNameQualified  *TableNameQualified  `'ON' @@`
	ColumnName          *ColumnName          `'(' @@`
	IndexUsing          *IndexUsing          `')' @@?`
	IndexOptionGroup    *IndexOptionGroup    `@@?`
	IndexOptionalUnique *IndexOptionalUnique `| @@?`
	ConstraintCluster   *ConstraintCluster   `@@?`
	IndexName2          *IndexName           `'INDEX' @@`
	TableNameQualified2 *TableNameQualified  `'ON' @@`
	IndexColumnList     *IndexColumnList     `'(' @@`
	ColumnNameList      *ColumnNameList      `')' ( 'INCLUDE' '(' @@ ')' )?`
	IndexOptionGroup2   *IndexOptionGroup    `@@? )`
}
type IndexColumnList struct {
	IndexColumn []*IndexColumn `@@ ( ',' @@ )*`
}
type IndexOptionalUnique struct {
	Unique bool `@( 'UNIQUE' )`
}
type IndexColumn struct {
	ColumnName *ColumnName `@@`
	OrderType  *OrderType  `@@?`
}
type IndexOptionGroup struct {
	IndexOptionList *IndexOptionList `'WITH' '(' @@ ')'`
}
type IndexOptionList struct {
	IndexOption []*IndexOption `@@ ( ',' @@ )*`
}
type IndexOption struct {
	Id             *string         `@ID`
	IntegerLiteral *IntegerLiteral `'=' @@`
	Id2            *string         `| @ID`
	Toggle         *Toggle         `'=' @@`
}
type IndexUsing struct {
	IndexName  *IndexName `'USING' 'XML' 'INDEX' @@ 'FOR' 'VALUE'`
	IndexName2 *IndexName `| 'USING' 'XML' 'INDEX' @@ 'FOR' 'PATH'`
	IndexName3 *IndexName `| 'USING' 'XML' 'INDEX' @@ 'FOR' 'PROPERTY'`
}
type DropIndexStatement struct {
	IndexName          *IndexName          `'DROP' 'INDEX' @@`
	TableNameQualified *TableNameQualified `'ON' @@`
	IndexOptionGroup   *IndexOptionGroup   `@@?`
}
type CreateTriggerStatement struct {
	TriggerNameQualified      *TriggerNameQualified      `'CREATE' 'TRIGGER' @@`
	TableNameQualified        *TableNameQualified        `'ON' @@`
	TriggerType               *TriggerType               `@@`
	TriggerOperationList      *TriggerOperationList      `@@`
	OptionalNotForReplication *OptionalNotForReplication `@@?`
	Statement                 *Statement                 `'AS' @@`
}
type TriggerType struct {
	ForInsteadOfAfter *string `@( 'FOR' | 'INSTEAD' 'OF' | 'AFTER' )`
}
type TriggerOperationList struct {
	TriggerOperation []*TriggerOperation `@@ ( ',' @@ )*`
}
type TriggerOperation struct {
	InsertUpdateDelete *string `@( 'INSERT' | 'UPDATE' | 'DELETE' )`
}
type OptionalNotForReplication struct {
	NotForReplication bool `@( 'NOT' 'FOR' 'REPLICATION' )`
}
type TriggerTarget struct {
	TableNameQualified *TableNameQualified `@@`
	Database           bool                `| @'DATABASE'`
	AllServer          bool                `| @( 'ALL' 'SERVER' )`
}
type EnableTriggerStatement struct {
	TriggerTarget            *TriggerTarget            `'ENABLE' ( 'TRIGGER' 'ALL' 'ON' @@`
	TriggerNameQualifiedList *TriggerNameQualifiedList `| 'TRIGGER' @@`
	TriggerTarget2           *TriggerTarget            `'ON' @@ )`
}
type DisableTriggerStatement struct {
	TriggerTarget            *TriggerTarget            `'DISABLE' ( 'TRIGGER' 'ALL' 'ON' @@`
	TriggerNameQualifiedList *TriggerNameQualifiedList `| 'TRIGGER' @@`
	TriggerTarget2           *TriggerTarget            `'ON' @@ )`
}
type TriggerNameQualifiedList struct {
	TriggerNameQualified []*TriggerNameQualified `@@ ( ',' @@ )*`
}
type DropTriggerStatement struct {
	TriggerNameQualified *TriggerNameQualified `'DROP' 'TRIGGER' @@`
}
type CreateXmlSchemaCollectionStatement struct {
	XmlSchemaCollectionNameQualified *XmlSchemaCollectionNameQualified `'CREATE' 'XML' 'SCHEMA' 'COLLECTION' @@`
	Expression                       *Expression                       `'AS' @@`
}
type DropXmlSchemaCollectionStatement struct {
	XmlSchemaCollectionNameQualified *XmlSchemaCollectionNameQualified `'DROP' 'XML' 'SCHEMA' 'COLLECTION' @@`
}
type CreateTypeStatement struct {
	SimpleTypeNameQualified *SimpleTypeNameQualified `'CREATE' 'TYPE' @@`
	TypeName                *TypeName                `( 'FROM' @@`
	TypeConstraint          *TypeConstraint          `@@?`
	TableDefinitionGroup    *TableDefinitionGroup    `| 'AS' 'TABLE' @@ )`
}
type TypeConstraint struct {
	NotNullNull *string `@( 'NOT' 'NULL' | 'NULL' )`
}
type DropTypeStatement struct {
	SimpleTypeNameQualified *SimpleTypeNameQualified `'DROP' 'TYPE' @@`
}
type TableDefinitionGroup struct {
	TableDefinitionList *TableDefinitionList `'(' @@ ')'`
}
type TableDefinitionList struct {
	TableDefinition []*TableDefinition `@@ ( ',' @@ )*`
}
type TableDefinition struct {
	ColumnName       *ColumnName       `@@`
	ColumnDefinition *ColumnDefinition `@@`
	TableConstraint  *TableConstraint  `| @@`
}
type TableConstraint struct {
	ConstraintName             *ConstraintName            `'CONSTRAINT' @@`
	ConstraintCluster          *ConstraintCluster         `'PRIMARY' 'KEY' @@?`
	IndexColumnList            *IndexColumnList           `'(' @@`
	ConstraintIndex            *ConstraintIndex           `')' @@?`
	ConstraintName2            *ConstraintName            `| 'CONSTRAINT' @@`
	ConstraintCluster2         *ConstraintCluster         `'UNIQUE' @@?`
	IndexColumnList2           *IndexColumnList           `'(' @@`
	ConstraintIndex2           *ConstraintIndex           `')' @@?`
	ConstraintName3            *ConstraintName            `| 'CONSTRAINT' @@`
	ColumnNameList             *ColumnNameList            `'FOREIGN' 'KEY' '(' @@`
	TableNameQualified         *TableNameQualified        `')' 'REFERENCES' @@`
	ColumnNameGroup            *ColumnNameGroup           `@@?`
	ForeignKeyActionList       *ForeignKeyActionList      `@@`
	ConstraintName4            *ConstraintName            `| 'CONSTRAINT' @@`
	OptionalNotForReplication  *OptionalNotForReplication `'CHECK' @@?`
	Predicate                  *Predicate                 `'(' @@ ')'`
	ConstraintCluster3         *ConstraintCluster         `| 'PRIMARY' 'KEY' @@?`
	IndexColumnList3           *IndexColumnList           `'(' @@`
	ConstraintIndex3           *ConstraintIndex           `')' @@?`
	ConstraintCluster4         *ConstraintCluster         `| 'UNIQUE' @@?`
	IndexColumnList4           *IndexColumnList           `'(' @@`
	ConstraintIndex4           *ConstraintIndex           `')' @@?`
	ColumnNameList2            *ColumnNameList            `| 'FOREIGN' 'KEY' '(' @@`
	TableNameQualified2        *TableNameQualified        `')' 'REFERENCES' @@`
	ColumnNameGroup2           *ColumnNameGroup           `@@?`
	ForeignKeyActionList2      *ForeignKeyActionList      `@@`
	OptionalNotForReplication2 *OptionalNotForReplication `| 'CHECK' @@?`
	Predicate2                 *Predicate                 `'(' @@ ')'`
}
type ForeignKeyActionList struct {
	ForeignKeyAction []*ForeignKeyAction `@@*`
}
type ForeignKeyAction struct {
	OnDeleteNoActionDeleteCascadeDeleteSetNullDeleteSetDefaultUpdateNoActionUpdateCascadeUpdateSetNullUpdateSetDefault bool `@( 'ON' ( 'DELETE' 'NO' 'ACTION' | 'DELETE' 'CASCADE' | 'DELETE' 'SET' 'NULL' | 'DELETE' 'SET' 'DEFAULT' | 'UPDATE' 'NO' 'ACTION' | 'UPDATE' 'CASCADE' | 'UPDATE' 'SET' 'NULL' | 'UPDATE' 'SET' 'DEFAULT' ) )`
}
type OptionalForeignRefColumn struct {
	ColumnName *ColumnName `'(' @@ ')'`
}
type ColumnDefinition struct {
	TypeNameQualified            *TypeNameQualified            `@@`
	ColumnConstraintList         *ColumnConstraintList         `@@`
	Expression                   *Expression                   `| 'AS' @@`
	ComputedColumnConstraintList *ComputedColumnConstraintList `@@`
}
type ColumnConstraintList struct {
	ColumnConstraint []*ColumnConstraint `@@*`
}
type ColumnConstraint struct {
	NamedColumnConstraint *NamedColumnConstraint `@@`
	CollationName         *CollationName         `| 'COLLATE' @@`
	Identity              bool                   `| @'IDENTITY'`
	IntegerLiteral        *string                `| 'IDENTITY' '(' @INTEGER_LITERAL`
	IntegerLiteral2       *string                `',' @INTEGER_LITERAL ')'`
	Rowguidcol            bool                   `| @'ROWGUIDCOL'`
	NotNull               bool                   `| @( 'NOT' 'NULL' )`
	Null                  bool                   `| @'NULL'`
}
type ComputedColumnConstraintList struct {
	ComputedColumnConstraint []*ComputedColumnConstraint `@@*`
}
type ComputedColumnConstraint struct {
	NamedColumnConstraint *NamedColumnConstraint `@@`
	Persisted             bool                   `| @'PERSISTED'`
	NotNull               bool                   `| @( 'NOT' 'NULL' )`
}
type NamedColumnConstraint struct {
	ConstraintName             *ConstraintName            `'CONSTRAINT' @@`
	ConstraintCluster          *ConstraintCluster         `'PRIMARY' 'KEY' @@?`
	ConstraintIndex            *ConstraintIndex           `@@?`
	ConstraintName2            *ConstraintName            `| 'CONSTRAINT' @@`
	ConstraintCluster2         *ConstraintCluster         `'UNIQUE' @@?`
	ConstraintIndex2           *ConstraintIndex           `@@?`
	ConstraintName3            *ConstraintName            `| 'CONSTRAINT' @@`
	TableNameQualified         *TableNameQualified        `'FOREIGN' 'KEY' 'REFERENCES' @@`
	OptionalForeignRefColumn   *OptionalForeignRefColumn  `@@?`
	ForeignKeyActionList       *ForeignKeyActionList      `@@`
	ConstraintName4            *ConstraintName            `| 'CONSTRAINT' @@`
	TableNameQualified2        *TableNameQualified        `'REFERENCES' @@`
	OptionalForeignRefColumn2  *OptionalForeignRefColumn  `@@?`
	ForeignKeyActionList2      *ForeignKeyActionList      `@@`
	ConstraintName5            *ConstraintName            `| 'CONSTRAINT' @@`
	OptionalNotForReplication  *OptionalNotForReplication `'CHECK' @@?`
	Predicate                  *Predicate                 `'(' @@ ')'`
	ConstraintName6            *ConstraintName            `| 'CONSTRAINT' @@`
	ConstraintDefaultValue     *ConstraintDefaultValue    `'DEFAULT' @@`
	ConstraintCluster3         *ConstraintCluster         `| 'PRIMARY' 'KEY' @@?`
	ConstraintIndex3           *ConstraintIndex           `@@?`
	ConstraintCluster4         *ConstraintCluster         `| 'UNIQUE' @@?`
	ConstraintIndex4           *ConstraintIndex           `@@?`
	TableNameQualified3        *TableNameQualified        `| 'FOREIGN' 'KEY' 'REFERENCES' @@`
	OptionalForeignRefColumn3  *OptionalForeignRefColumn  `@@?`
	ForeignKeyActionList3      *ForeignKeyActionList      `@@`
	TableNameQualified4        *TableNameQualified        `| 'REFERENCES' @@`
	OptionalForeignRefColumn4  *OptionalForeignRefColumn  `@@?`
	ForeignKeyActionList4      *ForeignKeyActionList      `@@`
	OptionalNotForReplication2 *OptionalNotForReplication `| 'CHECK' @@?`
	Predicate2                 *Predicate                 `'(' @@ ')'`
	ConstraintDefaultValue2    *ConstraintDefaultValue    `| 'DEFAULT' @@`
}
type ConstraintCluster struct {
	ClusteredNonclustered *string `@( 'CLUSTERED' | 'NONCLUSTERED' )`
}
type ConstraintDefaultValue struct {
	ExpressionParens *ExpressionParens `@@`
	FunctionCall     *FunctionCall     `| @@`
	NumberLiteral    *NumberLiteral    `| @@`
	StringLiteral    *StringLiteral    `| @@`
	Null             bool              `| @'NULL'`
}
type ConstraintIndex struct {
	IntegerLiteral   *IntegerLiteral   `'WITH' 'FILLFACTOR' '=' @@`
	IndexOptionGroup *IndexOptionGroup `| @@`
}
type QueryOptions struct {
	XmlNamespaceList *XmlNamespaceList `'WITH' ( 'XMLNAMESPACES' '(' @@`
	CTelist          *CTelist          `')' ( ',' @@ )?`
	CTelist2         *CTelist          `| @@ )`
}
type XmlNamespaceList struct {
	XmlNamespace []*XmlNamespace `@@ ( ',' @@ )*`
}
type XmlNamespace struct {
	StringLiteral    *StringLiteral    `@@`
	XmlNamespaceName *XmlNamespaceName `'AS' @@`
}
type CTelist struct {
	CTe []*CTe `@@ ( ',' @@ )*`
}
type CTe struct {
	AliasName       *AliasName       `@@`
	ColumnNameGroup *ColumnNameGroup `@@?`
	SelectQuery     *SelectQuery     `'AS' '(' @@ ')'`
}
type Top struct {
	Expression       *Expression       `'TOP' '(' @@`
	OptionalPercent  *OptionalPercent  `')' @@?`
	OptionalWithTies *OptionalWithTies `@@?`
}
type OptionalTop struct {
	Top *Top `@@`
}
type OptionalPercent struct {
	Percent bool `@( 'PERCENT' )`
}
type OptionalWithTies struct {
	WithTies bool `@( 'WITH' 'TIES' )`
}
type OutputClause struct {
	ColumnItemList    *ColumnItemList    `'OUTPUT' @@`
	DestinationRowset *DestinationRowset `( 'INTO' @@`
	ColumnNameGroup   *ColumnNameGroup   `@@? )?`
}
type QueryHint struct {
	QueryHintOptionList *QueryHintOptionList `'OPTION' '(' @@ ')'`
}
type QueryHintOption struct {
	IntegerLiteral       *string       `'MAXRECURSION' @INTEGER_LITERAL`
	Recompile            bool          `| @'RECOMPILE'`
	HashOrderGroup       bool          `| @( ( 'HASH' | 'ORDER' ) 'GROUP' )`
	IntegerLiteral2      *string       `| 'FAST' @INTEGER_LITERAL`
	ConcatHashMergeUnion bool          `| @( ( 'CONCAT' | 'HASH' | 'MERGE' ) 'UNION' )`
	VariableName         *VariableName `| 'OPTIMIZE' 'FOR' '(' @@`
	Expression           *Expression   `'=' @@ ')'`
}
type QueryHintOptionList struct {
	QueryHintOption []*QueryHintOption `@@ ( ',' @@ )*`
}
type InsertStatement struct {
	QueryOptions      *QueryOptions      `@@?`
	OptionalTop       *OptionalTop       `'INSERT' @@?`
	OptionalInto      *OptionalInto      `@@?`
	DestinationRowset *DestinationRowset `@@`
	QueryHint         *QueryHint         `( 'DEFAULT' 'VALUES' @@?`
	ColumnNameGroup   *ColumnNameGroup   `| @@?`
	OutputClause      *OutputClause      `@@?`
	ExpressionList    []*ExpressionList  `( 'VALUES' '(' @@ ')' ( ',' '(' @@ ')' )*`
	QueryHint2        *QueryHint         `@@?`
	SelectQuery       *SelectQuery       `| @@`
	QueryHint3        *QueryHint         `@@?`
	ExecuteStatement  *ExecuteStatement  `| @@`
	QueryHint4        *QueryHint         `@@? ) )`
}
type OptionalInto struct {
	Into bool `@( 'INTO' )`
}
type MergeStatement struct {
	QueryOptions         *QueryOptions         `@@?`
	OptionalTop          *OptionalTop          `'MERGE' @@?`
	OptionalInto         *OptionalInto         `@@?`
	DestinationRowset    *DestinationRowset    `@@`
	RowsetAlias          *RowsetAlias          `@@?`
	SourceRowset         *SourceRowset         `'USING' @@`
	Predicate            *Predicate            `'ON' @@`
	MergeWhenMatchedList *MergeWhenMatchedList `@@`
	OutputClause         *OutputClause         `@@?`
	QueryHint            *QueryHint            `@@?`
}
type MergeWhenMatchedList struct {
	MergeWhenMatched []*MergeWhenMatched `@@+`
}
type MergeWhenMatched struct {
	Predicate        *Predicate       `'WHEN' 'MATCHED' ( 'AND' @@ )?`
	MergeMatched     *MergeMatched    `'THEN' @@`
	Predicate2       *Predicate       `| 'WHEN' 'NOT' 'MATCHED' 'BY' 'TARGET' ( 'AND' @@ )?`
	MergeNotMatched  *MergeNotMatched `'THEN' @@`
	Predicate3       *Predicate       `| 'WHEN' 'NOT' 'MATCHED' ( 'AND' @@ )?`
	MergeNotMatched2 *MergeNotMatched `'THEN' @@`
	Predicate4       *Predicate       `| 'WHEN' 'NOT' 'MATCHED' 'BY' 'SOURCE' ( 'AND' @@ )?`
	MergeMatched2    *MergeMatched    `'THEN' @@`
}
type MergeMatched struct {
	UpdateItemList *UpdateItemList `'UPDATE' 'SET' @@ | 'DELETE'`
}
type MergeNotMatched struct {
	ColumnNameGroup  *ColumnNameGroup `'INSERT' @@?`
	ExpressionList   *ExpressionList  `'VALUES' '(' @@ ')'`
	ColumnNameGroup2 *ColumnNameGroup `| 'INSERT' @@? 'DEFAULT' 'VALUES'`
}
type UpdateStatement struct {
	QueryOptions       *QueryOptions       `@@?`
	OptionalTop        *OptionalTop        `'UPDATE' @@?`
	DestinationRowset  *DestinationRowset  `@@`
	UpdateItemList     *UpdateItemList     `'SET' @@`
	OutputClause       *OutputClause       `@@?`
	OptionalFromClause *OptionalFromClause `@@?`
	WhereClause        *WhereClause        `@@?`
	QueryHint          *QueryHint          `@@?`
}
type UpdateItemList struct {
	UpdateItem []*UpdateItem `@@ ( ',' @@ )*`
}
type AssignmentOperator struct {
	EqPlusEqMinusEqStarEqFslashEqPercentEqAmpEqCaretEqPipeEq *string `@( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '^=' | '|=' )`
}
type UpdateItem struct {
	ColumnNameFullyQualified *ColumnNameFullyQualified `@@`
	AssignmentOperator       *AssignmentOperator       `@@`
	Expression               *Expression               `@@`
	ColumnNameQualified      *ColumnNameQualified      `| @@ '=' 'DEFAULT'`
	VariableName             *VariableName             `| @@`
	ColumnNameQualified2     *ColumnNameQualified      `'=' ( @@ '=' )?`
	Expression2              *Expression               `@@`
	VariableName2            *VariableName             `| ( @@`
	TableName                *TableName                `| @@`
	ColumnName               *ColumnName               `( @@ '.' )? )`
	NamedFunctionList        *NamedFunctionList        `'.' @@`
}
type OptionalFromClause struct {
	FromClause *FromClause `@@`
}
type DeleteStatement struct {
	QueryOptions       *QueryOptions       `@@?`
	OptionalTop        *OptionalTop        `'DELETE' @@?`
	OptionalFrom       *OptionalFrom       `@@?`
	DestinationRowset  *DestinationRowset  `@@`
	OutputClause       *OutputClause       `@@?`
	OptionalFromClause *OptionalFromClause `@@?`
	WhereClause        *WhereClause        `@@?`
	QueryHint          *QueryHint          `@@?`
}
type OptionalFrom struct {
	From bool `@( 'FROM' )`
}
type SelectStatement struct {
	QueryOptions *QueryOptions `@@?`
	SelectQuery  *SelectQuery  `@@`
	QueryHint    *QueryHint    `@@?`
}
type SelectQuery struct {
	Restriction         *Restriction         `'SELECT' @@?`
	TopLegacy           *TopLegacy           `@@?`
	ColumnItemList      *ColumnItemList      `@@`
	IntoClause          *IntoClause          `@@?`
	FromClause          *FromClause          `@@`
	WhereClause         *WhereClause         `@@?`
	GroupClause         *GroupClause         `@@?`
	HavingClause        *HavingClause        `@@?`
	OptionalOrderClause *OptionalOrderClause `@@?`
	RowsetCombineClause *RowsetCombineClause `@@?`
	ComputeClause       *ComputeClause       `@@?`
}
type TopLegacy struct {
	IntegerLiteral   *string           `'TOP' ( @INTEGER_LITERAL`
	RealLiteral      *string           `| @REAL_LITERAL )`
	OptionalPercent  *OptionalPercent  `@@?`
	OptionalWithTies *OptionalWithTies `@@?`
	Top              *Top              `| @@`
}
type ColumnItemList struct {
	ColumnItem []*ColumnItem `@@ ( ',' @@ )*`
}
type ColumnItem struct {
	ColumnWildQualified *ColumnWildQualified `@@`
	Expression          *Expression          `| @@`
	AliasName           *AliasName           `'AS' @@`
	Expression2         *Expression          `| @@`
	AliasName2          *AliasName           `@@`
	AliasName3          *AliasName           `| @@`
	Expression3         *Expression          `'=' @@`
	VariableName        *VariableName        `| @@`
	Expression4         *Expression          `'=' @@`
	Expression5         *Expression          `| @@`
}
type Restriction struct {
	AllDistinct *string `@( 'ALL' | 'DISTINCT' )`
}
type IntoClause struct {
	DestinationRowset *DestinationRowset `'INTO' @@`
}
type FromClause struct {
	Source    *Source    `'FROM' @@`
	JoinChain *JoinChain `@@?`
}
type Source struct {
	Source       *Source       `'(' @@`
	JoinChain    *JoinChain    `@@? ')'`
	SourceRowset *SourceRowset `| @@`
}
type JoinChain struct {
	Join      *Join      `@@`
	JoinChain *JoinChain `@@?`
}
type Join struct {
	Source     *Source    `'JOIN' @@`
	Predicate  *Predicate `'ON' @@`
	JoinHint   *JoinHint  `| 'INNER' @@?`
	Source2    *Source    `'JOIN' @@`
	Predicate2 *Predicate `'ON' @@`
	JoinHint2  *JoinHint  `| 'LEFT' @@?`
	Source3    *Source    `'JOIN' @@`
	Predicate3 *Predicate `'ON' @@`
	JoinHint3  *JoinHint  `| 'LEFT' 'OUTER' @@?`
	Source4    *Source    `'JOIN' @@`
	Predicate4 *Predicate `'ON' @@`
	JoinHint4  *JoinHint  `| 'RIGHT' @@?`
	Source5    *Source    `'JOIN' @@`
	Predicate5 *Predicate `'ON' @@`
	JoinHint5  *JoinHint  `| 'RIGHT' 'OUTER' @@?`
	Source6    *Source    `'JOIN' @@`
	Predicate6 *Predicate `'ON' @@`
	JoinHint6  *JoinHint  `| 'FULL' @@?`
	Source7    *Source    `'JOIN' @@`
	Predicate7 *Predicate `'ON' @@`
	JoinHint7  *JoinHint  `| 'FULL' 'OUTER' @@?`
	Source8    *Source    `'JOIN' @@`
	Predicate8 *Predicate `'ON' @@`
	Source9    *Source    `| 'CROSS' 'JOIN' @@`
	Source10   *Source    `| 'CROSS' 'APPLY' @@`
	Source11   *Source    `| 'OUTER' 'APPLY' @@`
}
type JoinHint struct {
	MergeHashLoop *string `@( 'MERGE' | 'HASH' | 'LOOP' )`
}
type SourceRowset struct {
	ValuesList         *ValuesList         `'(' 'VALUES' @@`
	RowsetAlias        *RowsetAlias        `')' @@?`
	SelectQuery        *SelectQuery        `| '(' @@`
	RowsetAlias2       *RowsetAlias        `')' @@?`
	SchemaName         *SchemaName         `| @@`
	TableName          *TableName          `'.' ( @@`
	SchemaName2        *SchemaName         `'.' ( @@`
	TableName2         *TableName          `'.' @@`
	RowsetAlias3       *RowsetAlias        `@@?`
	TableName3         *TableName          `| @@`
	RowsetAlias4       *RowsetAlias        `@@?`
	NamedFunction      *NamedFunction      `| @@`
	RowsetAlias5       *RowsetAlias        `@@? )`
	NamedFunction2     *NamedFunction      `| @@`
	RowsetAlias6       *RowsetAlias        `@@? )`
	VariableName       *VariableName       `| @@`
	ColumnName         *ColumnName         `( '.' ( @@`
	NamedFunction3     *NamedFunction      `'.' @@`
	RowsetAlias7       *RowsetAlias        `@@?`
	NamedFunction4     *NamedFunction      `| @@`
	RowsetAlias8       *RowsetAlias        `@@? )`
	RowsetAlias9       *RowsetAlias        `| @@ )?`
	TableNameQualified *TableNameQualified `| @@`
	RowsetAlias10      *RowsetAlias        `@@?`
	TableHintGroup     *TableHintGroup     `@@?`
	Openxml            *Openxml            `| @@`
	RowsetAlias11      *RowsetAlias        `@@?`
	TextTableFunction  *TextTableFunction  `| @@`
	RowsetAlias12      *RowsetAlias        `@@?`
	NamedFunction5     *NamedFunction      `| @@`
	RowsetAlias13      *RowsetAlias        `@@?`
}
type RowsetAlias struct {
	AliasName       *AliasName      `'AS' @@`
	ColumnNameList  *ColumnNameList `'(' @@ ')'`
	AliasName2      *AliasName      `| @@`
	ColumnNameList2 *ColumnNameList `'(' @@ ')'`
	AliasName3      *AliasName      `| 'AS' @@`
	AliasName4      *AliasName      `| @@`
}
type ValuesList struct {
	ExpressionList *ExpressionList `'(' @@`
	ValuesList     []*ValuesList   `')' ( ',' @@ )*`
}
type TextTableFunction struct {
	TableNameQualified  *TableNameQualified  `( 'CONTAINSTABLE' | 'FREETEXTTABLE' ) '(' @@`
	ColumnName          *ColumnName          `',' ( @@`
	ColumnWild          *ColumnWild          `| @@`
	ColumnNameList      *ColumnNameList      `| '(' @@ ')' )`
	Expression          *Expression          `',' @@`
	Literal             *Literal             `( ',' 'LANGUAGE' @@ )?`
	OptionalContainsTop *OptionalContainsTop `@@? ')'`
}
type OptionalContainsTop struct {
	IntegerLiteral *IntegerLiteral `',' @@`
}
type TableHintGroup struct {
	TableHintList *TableHintList `'WITH' '(' @@ ')' | 'WITH'? ( '(NOLOCK)' | '(READUNCOMMITTED)' | '(UPDLOCK)' | '(REPEATABLEREAD)' | '(SERIALIZABLE)' | '(READCOMMITTED)' | '(TABLOCK)' | '(TABLOCKX)' | '(PAGLOCK)' | '(ROWLOCK)' | '(NOWAIT)' | '(READPAST)' | '(XLOCK)' | '(NOEXPAND)' )`
}
type TableHintList struct {
	TableHint []*TableHint `@@ ( ',' @@ )*`
}
type TableHint struct {
	IndexValue        *IndexValue     `'INDEX' ( '=' @@`
	IndexValueList    *IndexValueList `| '(' @@ ')' )`
	Holdlock          bool            `| @'HOLDLOCK'`
	Id                *string         `| @ID`
	Nolock            bool            `| @'NOLOCK'`
	Nowait            bool            `| @'NOWAIT'`
	Paglock           bool            `| @'PAGLOCK'`
	Readcommitted     bool            `| @'READCOMMITTED'`
	Readcommittedlock bool            `| @'READCOMMITTEDLOCK'`
	Readpast          bool            `| @'READPAST'`
	Readuncommitted   bool            `| @'READUNCOMMITTED'`
	Repeatableread    bool            `| @'REPEATABLEREAD'`
	Rowlock           bool            `| @'ROWLOCK'`
	Serializable      bool            `| @'SERIALIZABLE'`
	Tablock           bool            `| @'TABLOCK'`
	Tablockx          bool            `| @'TABLOCKX'`
	Updlock           bool            `| @'UPDLOCK'`
	Xlock             bool            `| @'XLOCK'`
}
type IndexValueList struct {
	IndexValue []*IndexValue `@@ ( ',' @@ )*`
}
type IndexValue struct {
	IntegerLiteral *string     `@INTEGER_LITERAL`
	ObjectName     *ObjectName `| @@`
}
type WhereClause struct {
	Predicate    *Predicate    `'WHERE' @@`
	VariableName *VariableName `| 'WHERE' 'CURRENT' 'OF' ( @@`
	CursorName   *CursorName   `| @@ )`
}
type GroupClause struct {
	ExpressionList *ExpressionList `'GROUP' 'BY' @@`
}
type OrderClause struct {
	OrderList *OrderList `'ORDER' 'BY' @@`
}
type OptionalOrderClause struct {
	OrderClause *OrderClause `@@`
}
type OrderList struct {
	Order []*Order `@@ ( ',' @@ )*`
}
type Order struct {
	Expression *Expression `@@`
	OrderType  *OrderType  `@@?`
}
type OrderType struct {
	AscDesc *string `@( 'ASC' | 'DESC' )`
}
type HavingClause struct {
	Predicate *Predicate `'HAVING' @@`
}
type ComputeClause struct {
	ColumnItemList  *ColumnItemList `'COMPUTE' @@`
	ColumnItemList2 *ColumnItemList `( 'BY' @@ )?`
}
type RowsetCombineClause struct {
	SelectQuery  *SelectQuery `'UNION' 'ALL'? ( '(' @@ ')'`
	SelectQuery2 *SelectQuery `| @@ )`
	SelectQuery3 *SelectQuery `| 'EXCEPT' @@`
	SelectQuery4 *SelectQuery `| 'INTERSECT' @@`
}
type ForClause struct {
	XmlDirectiveList     *XmlDirectiveList    `'FOR' ( 'BROWSE' | 'XML' 'AUTO' @@`
	OptionalElementName  *OptionalElementName `| 'XML' 'RAW' @@?`
	XmlDirectiveList2    *XmlDirectiveList    `@@`
	XmlDirectiveList3    *XmlDirectiveList    `| 'XML' 'EXPLICIT' @@`
	OptionalElementName2 *OptionalElementName `| 'XML' 'PATH' @@?`
	XmlDirectiveList4    *XmlDirectiveList    `@@ | 'READ' 'ONLY' )`
}
type OptionalElementName struct {
	StringLiteral *string `'(' @STRING_LITERAL ')'`
}
type XmlDirectiveList struct {
	XmlDirective []*XmlDirective `( ',' @@ )*`
}
type XmlDirective struct {
	Id                  *string              `@ID`
	OptionalElementName *OptionalElementName `@@?`
	Id2                 *string              `| @ID`
	Id3                 *string              `@ID`
}
type Predicate struct {
	PredicateOr *PredicateOr `@@`
}
type PredicateOr struct {
	PredicateAnd *PredicateAnd `@@`
	PredicateOr  *PredicateOr  `( 'OR' @@ )?`
}
type PredicateAnd struct {
	PredicateNot *PredicateNot `@@`
	PredicateAnd *PredicateAnd `( 'AND' @@ )?`
}
type PredicateNot struct {
	PredicateCompare *PredicateCompare `'NOT'? @@`
}
type PredicateCompare struct {
	Expression        *Expression        `@@`
	Op                *string            `( @( '=' | '>' | '<' | '>=' | '<=' | '<>' | '!=' | '!<' | '!>' )`
	Expression2       *Expression        `@@ | 'IS' 'NOT'? 'NULL'`
	Expression3       *Expression        `| 'NOT'? 'BETWEEN' @@`
	Expression4       *Expression        `'AND' @@`
	Expression5       *Expression        `| 'NOT'? 'LIKE' @@`
	StringLiteral     *string            `( 'ESCAPE' @STRING_LITERAL )?`
	Tuple             *Tuple             `| 'NOT'? 'IN' @@ )`
	PredicateFunction *PredicateFunction `| @@`
}
type Tuple struct {
	SelectQuery    *SelectQuery    `'(' ( @@`
	ExpressionList *ExpressionList `| @@ ) ')'`
}
type ExpressionList struct {
	Expression []*Expression `@@ ( ',' @@ )*`
}
type PredicateFunction struct {
	SelectQuery             *SelectQuery             `'EXISTS' '(' @@ ')'`
	ColumnName              *ColumnName              `| 'UPDATE' '(' @@ ')' | ( 'CONTAINS' | 'FREETEXT' )`
	ColumnNameQualifiedList *ColumnNameQualifiedList `( '(' '(' @@`
	Expression              *Expression              `')' ',' @@`
	Literal                 *Literal                 `( ',' 'LANGUAGE' @@ )? ')'`
	ColumnWildNameQualified *ColumnWildNameQualified `| '(' @@`
	Expression2             *Expression              `',' @@`
	Literal2                *Literal                 `( ',' 'LANGUAGE' @@ )? ')' )`
	PredicateParens         *PredicateParens         `| @@`
}
type PredicateParens struct {
	Predicate *Predicate `'(' @@ ')'`
}
type Expression struct {
	ExpressionAdd *ExpressionAdd `@@`
}
type ExpressionAdd struct {
	ExpressionMult *ExpressionMult `@@`
	Op             *string         `( @( '+' | '-' | '&' | '|' | '^' )`
	ExpressionAdd  *ExpressionAdd  `@@ )?`
}
type ExpressionMult struct {
	ExpressionNegate *ExpressionNegate `@@`
	Op               *string           `( @( '*' | '/' | '%' )`
	ExpressionMult   *ExpressionMult   `@@ )?`
}
type ExpressionNegate struct {
	Op             *string         `@( '-' | '+' | '~' )?`
	ExpressionCase *ExpressionCase `@@`
}
type RankingArguments struct {
	ExpressionList      *ExpressionList      `'PARTITION' 'BY' @@`
	OptionalOrderClause *OptionalOrderClause `@@?`
	OrderClause         *OrderClause         `| @@`
}
type ExpressionCase struct {
	CaseWhenPredicateList  *CaseWhenPredicateList  `'CASE' ( @@`
	Expression             *Expression             `| @@`
	CaseWhenExpressionList *CaseWhenExpressionList `@@ )`
	Expression2            *Expression             `( 'ELSE' @@ 'END' )? 'END'`
	CollatedValue          *CollatedValue          `| @@`
}
type CaseWhenExpressionList struct {
	CaseWhenExpression []*CaseWhenExpression `@@+`
}
type CaseWhenExpression struct {
	Expression  *Expression `'WHEN' @@`
	Expression2 *Expression `'THEN' @@`
}
type CaseWhenPredicateList struct {
	CaseWhenPredicate []*CaseWhenPredicate `@@+`
}
type CaseWhenPredicate struct {
	Predicate  *Predicate  `'WHEN' @@`
	Expression *Expression `'THEN' @@`
}
type CollatedValue struct {
	Value         *Value         `@@`
	CollationName *CollationName `'COLLATE' @@`
	Value2        *Value         `| @@`
	Literal       *Literal       `| @@`
}
type FunctionCall struct {
	Expression       *Expression     `( 'CAST' | 'TRY_CAST' ) '(' @@`
	TypeName         *TypeName       `'AS' @@ ')'`
	ExpressionList   *ExpressionList `| 'COALESCE' '(' @@ ')'`
	Expression2      *Expression     `| 'NULLIF' '(' @@`
	Expression3      *Expression     `',' @@ ')'`
	Expression4      *Expression     `| 'LEFT' '(' @@`
	Expression5      *Expression     `',' @@ ')'`
	Expression6      *Expression     `| 'RIGHT' '(' @@`
	Expression7      *Expression     `',' @@ ')' | ( 'CONVERT' | 'TRY_CONVERT' )`
	TypeName2        *TypeName       `'(' @@`
	Expression8      *Expression     `',' @@`
	IntegerLiteral   *string         `( ',' @INTEGER_LITERAL )? ')'`
	Restriction      *Restriction    `| 'COUNT' '(' @@?`
	ColumnWild       *ColumnWild     `( @@`
	Expression9      *Expression     `| @@ ) ')'`
	TypeName3        *TypeName       `| 'IDENTITY' '(' @@`
	IntegerLiteral2  *IntegerLiteral `( ',' @@`
	IntegerLiteral3  *IntegerLiteral `',' @@ )? ')'`
	CurrentTimestamp bool            `| @'CURRENT_TIMESTAMP'`
	CurrentUser      bool            `| @'CURRENT_USER'`
	SessionUser      bool            `| @'SESSION_USER'`
	SystemUser       bool            `| @'SYSTEM_USER'`
	User             bool            `| @'USER'`
	NamedFunction    *NamedFunction  `| @@`
}
type NamedFunction struct {
	Callable       *Callable       `@@`
	ExpressionList *ExpressionList `'(' @@? ')'`
}
type Callable struct {
	ObjectName    *ObjectName `@@`
	ObjectName2   *ObjectName `( '.' @@`
	SystemFuncId  *string     `| @SYSTEM_FUNC_ID )`
	ObjectName3   *ObjectName `| @@`
	SystemFuncId2 *string     `| @SYSTEM_FUNC_ID`
}
type NamedFunctionList struct {
	NamedFunction []*NamedFunction `@@ ( '.' @@ )*`
}
type Value struct {
	FunctionCall         *FunctionCall        `@@`
	NamedFunctionList    *NamedFunctionList   `( '.' @@ )?`
	SchemaName           *SchemaName          `| @@`
	ColumnNameQualified  *ColumnNameQualified `'.' @@`
	ColumnNameQualified2 *ColumnNameQualified `| @@`
	VariableName         *VariableName        `| @@`
	ExpressionParens     *ExpressionParens    `| @@`
	NamedFunctionList2   *NamedFunctionList   `( '.' @@ )?`
	TableName            *TableName           `| @@`
	NamedFunctionList3   *NamedFunctionList   `'.' @@`
	TableName2           *TableName           `| @@`
	ColumnName           *ColumnName          `'.' @@`
	NamedFunctionList4   *NamedFunctionList   `'.' @@`
	FunctionCall2        *FunctionCall        `| @@`
	RankingArguments     *RankingArguments    `'OVER' '(' @@ ')'`
	SystemVariableName   *SystemVariableName  `| @@`
}
type ExpressionParens struct {
	SelectQuery *SelectQuery `( 'ANY' | 'ALL' )? '(' ( @@`
	Expression  *Expression  `| @@ ) ')'`
}
